from __future__ import annotations  # noqa
from copy import deepcopy
from typing import Type, Optional, List
from pathlib import Path

import numpy as np
from numpy.typing import ArrayLike
from scipy.interpolate import InterpolatedUnivariateSpline, RectBivariateSpline

from ..dataset_wrapper import DatasetWrapper
from ..readers import Reader, create_reader_factory
from ..typing import PathLike
from ..normalisation import ureg as units
from .flux_surface import _flux_surface_contour, FluxSurface
from .equilibrium_units import eq_units


# Define unit-aware wrapper classes for splines
# Assumes that x and y are pint Quantities
# WARNING: Do not use functions like 'derviative()' or 'partial_derivative()', as
# these create a new scipy spline, and unit info will be lost.


class _UnitSpline(InterpolatedUnivariateSpline):
    def __init__(self, x, y, *args, **kwargs):
        self.x_units = x.units
        self.y_units = y.units
        super().__init__(x.magnitude, y.magnitude, *args, **kwargs)

    def __call__(self, x, nu=0, **kwargs):
        u = self.y_units
        if nu:
            u /= self.x_units**nu
        return super().__call__(x.magnitude, nu=nu, **kwargs) * u


class _UnitSpline2D(RectBivariateSpline):
    def __init__(self, x, y, z, *args, **kwargs):
        self.x_units = x.units
        self.y_units = y.units
        self.z_units = z.units
        super().__init__(x.magnitude, y.magnitude, z.magnitude, *args, **kwargs)

    def __call__(self, x, y, dx=0, dy=0, **kwargs):
        u = self.z_units
        if dx:
            u /= self.x_units**dx
        if dy:
            u /= self.y_units**dy
        return super().__call__(x.magnitude, y.magnitude, dx=dx, dy=dy, **kwargs) * u


class Equilibrium(DatasetWrapper):
    r"""
    Contains a solution of the Grad-Shafranov equation, which defines a tokamak plasma
    equilibrium. Users are not expected to initialise ``Equilibrium`` objects directly,
    and in most cases should instead make use of the function ``read_equilibrium``,
    which can read popular plasma equilibrium file types such as GEQDSK, generated by
    tools such as FreeGS_ and EFIT_, or netCDF4 files generated by TRANSP_ or VMEC_.
    Adheres the the convention COCOS 1.

    .. _FreeGS: https://github.com/freegs-plasma/freegs
    .. _EFIT: https://omfit.io/modules/mod_EFIT++.html
    .. _TRANSP: https://transp.pppl.gov/
    .. _VMEC: https://princetonuniversity.github.io/STELLOPT/VMEC

    Parameters
    ----------

    r: ArrayLike, units [meter]
        Linearly spaced and monotonically increasing 1D grid of major radius
        coordinates. This is the radius from the central column of a tokamak, and not
        the radial distance from the magnetic axis.
    z: ArrayLike, units [meter]
        Linearly spaced and monotonically increasing 1D grid of tokamak z-coordinates.
        This is usually the height above the plasma midplane, but z=0 may be set at any
        reference point.
    psi_rz: ArrayLike, units [webers / radian]
        2D grid defining the poloidal magnetic flux function :math::`\psi` with respect
        to ``r`` and ``z``. Should have the shape ``(len(r), len(z))``.
    psi: ArrayLike, units [weber / radian]
        Monotonically increasing 1D grid defining the poloidal magnetic flux function.
        This grid defines magnetic flux surface coordinates, on which most other
        parameters are defined. ``psi[0]`` should be the value of ``psi`` on the
        magnetic axis.
    f: ArrayLike, units [meter * tesla]
        1D grid defining the poloidal current function with respect to ``psi``. Should
        have the same length as ``psi``.
    ff_prime: ArrayLike, units [meter**2 * tesla**2 * radian / weber]
        1D grid defining the poloidal current function ``f`` multiplied by its
        derivative with respect to ``psi``. Should have the same length as ``psi``.
    p: ArrayLike, units [pascal]
        1D grid defining the plasma pressure with respect to ``psi``. Should have the
        same length as ``psi``.
    p_prime: ArrayLike, units [pascal * radian / weber]
        1D grid defining the derivative of the plasma pressure with respect to ``psi``.
        Should have the same length as ``psi``.
    q: ArrayLike, units [dimensionless]
        1D grid defining the 'safety factor' with respect to ``psi``. Should have same
        length as ``psi``.
    r_major: ArrayLike, units [meter]
        1D grid of the major radius positions of the center of each flux surface with
        respect to ``psi``. Should have the same length as ``psi``. This should be given
        by the mean of the maximum and minimum major radii of the flux surface.
        ``r_major[0]`` should be the major radius of the magnetic axis.
    r_minor: ArrayLike, units[meter]
        1D grid of the minor radius of each flux surface with respect to ``psi``. Should
        have the same length as ``psi``. This should be half of the difference between
        the maximum and minimum major radii of a flux surface. ``r_minor[0]`` should be
        0.0.
    z_mid: ArrayLike, units [meter]
        1D grid of the z-midpoint of each flux surface with respace to ``psi``. Should
        have the same length as ``psi``. This should be the mean of the maximum and
        minimum z-positions of the flux surface. ``z_mid[0]`` should be the z-position
        of the magnetic axis.
    psi_lcfs: float, units [weber / radian]
        The value of ``psi`` on the last closed flux surface (LCFS).
    a_minor: float, units [meter]
        The minor radius of the last closed flux surface (LCFS). The minor radius of a
        flux surface is half of the difference between its maximum and minimum major
        radii.
    eq_type: Optional[str]
        A label denoting the type of Equilibrium, such as "GEQDSK", "TRANSP", "VMEC",
        etc.


    Attributes
    ----------

    data: xarray.Dataset
        The internal representation of the ``Equilibrium`` object. The functions
        ``__getattr__`` and ``__getitem__`` redirect most attribute/indexing lookups
        here, but the Dataset itself may be accessed directly by the user if they wish
        to perform more complex manipulations.
    r_axis: float, units [meter]
        Major radius position of the magnetic axis.
    z_axis: float, units [meter]
        Vertical position of the magnetic axis, in meters.
    psi_axis: float, units [weber / radian]
        Poloidal magnetic flux function :math:`\psi` on the magnetic axis.
    psi_lcfs: float, units [weber / radian]
        Poloidal magnetic flux function :math:`\psi` on the last closed flux surface.
    a_minor: float, units [meter]
        Minor radius of the last closed flux surface.
    dr: float, units [meter]
        Grid spacing in the radial direction.
    dz: float, units [meter]
        Grid spacing in the vertical direction.
    eq_type: str
        Type of equilibrium

    See Also
    --------
    read_equilibrium: Create ``Equilibrium`` from a file.
    FluxSurface: An individual flux surface created from an ``Equilibrium``.

    Notes
    -----

    The Grad-Shafranov equation [1]_ may be written:

    .. math::
        \frac{\partial^2 \psi}{\partial r^2}
        - \frac{1}{r}\frac{\partial\psi}{\partial r}
        + \frac{\partial^2 \psi}{\partial z^2}
        = -\mu_0 r^2 p'(\psi) - f(\psi)f'(\psi)

    The :math:`r` coordinate is the major radius, the distance from the central column
    of a tokamak, and :math:`z` is the height within the tokamak (often defined as the
    vertical distance about the tokamak midplane, but other reference points may be used
    instead).

    :math:`\psi` is the poloidal magnetic flux function, defined as:

    .. math::
        \vec{B_p} = \frac{1}{r} \nabla\psi \times \hat{\phi}

    where :math:`\vec{B_p}` is the poloidal magnetic field vector, and
    :math:`\hat{\phi}` is the unit vector in the toroidal direction. :math:`\psi` is
    arbitrary to within an additive constant. :math:`f` is the poloidal current
    function, and is defined similarly:

    .. math::
        \vec{J_p} = \frac{\mu_0}{r} \nabla f \times \hat{\phi}

    where :math:`\vec{J_p}` is the poloidal current density. It may be shown that
    :math:`f` is a function of :math:`\psi` only, as is the plasma pressure, :math:`p`.
    Along with the safety factor, :math:`q(\psi)`:

    .. math::
        q = \frac{1}{2\pi}\oint \frac{1}{r} \frac{B_\phi}{B_p} ds

    which describes the number of times a magnetic field line wraps around the toroidal
    direction before arriving at the same point in the poloidal plane, these quantities
    describe a plasma equilibrium in full.

    For gyrokinetics simulations, it is common for researchers to make use of the
    normalised :math:`\psi_n`, which is scaled so that :math:`\psi_n=0` at the magnetic
    axis, and :math:`\psi_n=1` at the Last Closed Flux Surface (LCFS).

    .. [1] J. Wesson and D.J. Campbell: "Tokamaks", Oxford University Press, 2011,
        chapter 3
    """

    _init_units = {
        "self": None,
        "r": eq_units["len"],
        "z": eq_units["len"],
        "psi_rz": eq_units["psi"],
        "psi": eq_units["psi"],
        "f": eq_units["f"],
        "ff_prime": eq_units["ff_prime"],
        "p": eq_units["p"],
        "p_prime": eq_units["p_prime"],
        "q": eq_units["q"],
        "r_major": eq_units["len"],
        "r_minor": eq_units["len"],
        "z_mid": eq_units["len"],
        "psi_lcfs": eq_units["psi"],
        "a_minor": eq_units["len"],
        "eq_type": None,
    }

    @units.wraps(None, [*_init_units.values()], strict=False)
    def __init__(
        self,
        r: ArrayLike,
        z: ArrayLike,
        psi_rz: ArrayLike,
        psi: ArrayLike,
        f: ArrayLike,
        ff_prime: ArrayLike,
        p: ArrayLike,
        p_prime: ArrayLike,
        q: ArrayLike,
        r_major: ArrayLike,
        r_minor: ArrayLike,
        z_mid: ArrayLike,
        psi_lcfs: float,
        a_minor: float,
        eq_type: Optional[str] = None,
    ) -> None:
        # Check the grids r, z, and psi_rz
        r = np.asanyarray(r, dtype=float) * eq_units["len"]
        z = np.asanyarray(z, dtype=float) * eq_units["len"]
        psi_rz = np.asanyarray(psi_rz, dtype=float) * eq_units["psi"]
        # Check that r and z are linearly spaced and increasing 1D grids
        for name, grid in {"r": r, "z": z}.items():
            if len(grid.shape) != 1:
                raise ValueError(f"The grid {name} must be 1D.")
            diff = np.diff(grid)
            if not np.allclose(diff, diff[0]):
                raise ValueError(f"The grid {name} must linearly spaced.")
            if diff[0] <= 0.0:
                raise ValueError(f"The grid {name} must have a positive spacing.")
        # Check that psi_rz has the correct dimensions
        shape_2d = (len(r), len(z))
        if not np.array_equal(psi_rz.shape, shape_2d):
            raise ValueError(
                f"The grid psi_rz has shape {psi_rz.shape}. "
                f"It should have shape {shape_2d}."
            )

        # Create bivariate spline and partial derivatives over psi_rz
        self._psi_rz_spline = _UnitSpline2D(r, z, psi_rz)

        # Check the psi grids
        psi = np.asanyarray(psi, dtype=float) * eq_units["psi"]
        f = np.asanyarray(f, dtype=float) * eq_units["f"]
        ff_prime = np.asanyarray(ff_prime, dtype=float) * eq_units["ff_prime"]
        p = np.asanyarray(p, dtype=float) * eq_units["p"]
        p_prime = np.asanyarray(p_prime, dtype=float) * eq_units["p_prime"]
        q = np.asanyarray(q, dtype=float) * eq_units["q"]
        r_major = np.asanyarray(r_major, dtype=float) * eq_units["len"]
        r_minor = np.asanyarray(r_minor, dtype=float) * eq_units["len"]
        z_mid = np.asanyarray(z_mid, dtype=float) * eq_units["len"]
        # Ensure psi is 1D and monotonically increasing
        if len(psi.shape) != 1:
            raise ValueError("The grid psi must be 1D.")
        if np.any(np.diff(psi) <= 0):
            raise ValueError("The grid psi must have a positive spacing.")
        # Ensure all psi grids have the correct shape
        psi_grids = {
            "f": f,
            "ff_prime": ff_prime,
            "p": p,
            "p_prime": p_prime,
            "q": q,
            "r_major": r_major,
            "r_minor": r_minor,
            "z_mid": z_mid,
        }
        psi_shape = psi.shape
        for name, grid in psi_grids.items():
            if not np.array_equal(grid.shape, psi_shape):
                raise ValueError(
                    f"The grid {name} has shape {grid.shape}. "
                    f"It should have shape {psi_shape}."
                )

        # Check that floats are valid
        psi_lcfs = float(psi_lcfs) * eq_units["psi"]
        if psi_lcfs < psi[0]:
            raise ValueError("psi_lcfs should be greater than psi[0].")
        a_minor = float(a_minor) * eq_units["len"]
        if a_minor <= 0.0:
            raise ValueError("a_minor should be a positive float.")

        # Check r_minor and create normalised version 'rho'
        if r_minor[0] != 0.0:
            raise ValueError("r_minor[0] should be zero.")
        if np.any(np.diff(r_minor) <= 0):
            raise ValueError("The grid r_minor must have a positive spacing.")
        rho = r_minor / a_minor

        # Create normalised 1d psi grid
        psi_n = (psi - psi[0]) / (psi_lcfs - psi[0])

        # Create spline functions for all psi grids with respect to psi
        self._f_psi_spline = _UnitSpline(psi, f)
        self._ff_prime_psi_spline = _UnitSpline(psi, ff_prime)
        self._p_psi_spline = _UnitSpline(psi, p)
        self._p_prime_psi_spline = _UnitSpline(psi, p_prime)
        self._q_psi_spline = _UnitSpline(psi, q)
        self._r_major_psi_spline = _UnitSpline(psi, r_major)
        self._r_minor_psi_spline = _UnitSpline(psi, r_minor)
        self._z_mid_psi_spline = _UnitSpline(psi, z_mid)

        # Assemble grids into underlying xarray Dataset
        def make_var(dim, val, desc):
            return (dim, val, {"units": str(val.units), "long_name": desc})

        coords = {
            "r": make_var("r_dim", r, "R Major Position"),
            "z": make_var("z_dim", z, "Vertical Position"),
            "psi": make_var("psi_dim", psi, "Poloidal Flux"),
        }

        data_vars = {
            "psi_rz": make_var(("r_dim", "z_dim"), psi_rz, "Poloidal Flux"),
            "f": make_var("psi_dim", f, "Poloidal Current"),
            "ff_prime": make_var("psi_dim", ff_prime, "ff'(psi)"),
            "p": make_var("psi_dim", p, "Plasma Pressure"),
            "p_prime": make_var("psi_dim", p_prime, "p'(psi)"),
            "q": make_var("psi_dim", q, "Safety Factor"),
            "r_major": make_var("psi_dim", r_major, "Flux Surface R Major Midpoint"),
            "r_minor": make_var("psi_dim", r_minor, "Flux Surface Width"),
            "z_mid": make_var("psi_dim", z_mid, "Flux Surface Vertical Midpoint"),
            "rho": make_var("psi_dim", rho, "Normalised Flux Surface Width"),
            "psi_n": make_var("psi_dim", psi_n, "Normalised Poloidal Flux"),
        }

        # TODO Is there a better way to handle attribute units?
        #      When writing to netCDF, global attrs must be from a select number of
        #      types. They can't have their own "units" attribute. Here, we strip units,
        #      and each attr has its own property which puts them back.
        attrs = {
            "r_axis": r_major[0].magnitude[()],
            "z_axis": z_mid[0].magnitude[()],
            "psi_axis": psi[0].magnitude[()],
            "psi_lcfs": psi_lcfs.magnitude[()],
            "a_minor": a_minor.magnitude[()],
            "dr": (r[1] - r[0]).magnitude[()],
            "dz": (z[1] - z[0]).magnitude[()],
            "eq_type": str(eq_type),
        }

        super().__init__(data_vars=data_vars, coords=coords, attrs=attrs)

    # define properties for read-only access to attrs
    r_axis = property(lambda self: self.data.r_axis * eq_units["len"])
    z_axis = property(lambda self: self.data.z_axis * eq_units["len"])
    psi_axis = property(lambda self: self.data.psi_axis * eq_units["psi"])
    psi_lcfs = property(lambda self: self.data.psi_lcfs * eq_units["psi"])
    a_minor = property(lambda self: self.data.a_minor * eq_units["len"])
    dr = property(lambda self: self.data.dr * eq_units["len"])
    dz = property(lambda self: self.data.dz * eq_units["len"])
    eq_type = property(lambda self: self.data.eq_type)

    @units.wraps(eq_units["psi"], (None, units.dimensionless), strict=False)
    def psi(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return actual poloidal magnetic flux function :math:`\psi` for a given
        normalised :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]
            Normalised poloidal magnetic flux function, scaled such that
            :math:`\psi_n=0` on the magnetic axis and :math:`\psi_n=1` on the last
            closed flux surface. Results are undefined outside this range.

        Returns
        -------
        np.ndarray, units [weber / radian]
            Actual poloidal magnetic flux. Note that the result is arbitrary within an
            additive constant.
        """
        # units introduced via self.psi_axis and self.psi_lcfs
        return self.psi_axis + np.asanyarray(psi_n) * (self.psi_lcfs - self.psi_axis)

    @units.wraps(units.dimensionless, (None, eq_units["psi"]), strict=False)
    def psi_n(self, psi: ArrayLike) -> np.ndarray:
        r"""
        Return normalised poloidal magnetic flux function :math:`\psi_n` for a given
        actual :math:`\psi`.

        Parameters
        ----------
        psi: ArrayLike, units [weber / radian]
            Actual poloidal magnetic flux. Note that the result is arbitrary within an
            additive constant.

        Returns
        -------
        np.ndarray, units [dimensionless]
            Normalised poloidal magnetic flux function, scaled such that
            :math:`\psi_n=0` on the magnetic axis and :math:`\psi_n=1` on the last
            closed flux surface. Results are undefined outside this range.
        """
        psi = np.asanyarray(psi) * eq_units["psi"]
        return (psi - self.psi_axis) / (self.psi_lcfs - self.psi_axis)

    @units.wraps(eq_units["f"], (None, units.dimensionless), strict=False)
    def f(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return poloidal current function :math:`f` at the normalised poloidal magnetic
        flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * tesla]
        """
        return self._f_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["ff_prime"], (None, units.dimensionless), strict=False)
    def ff_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return poloidal current function :math:`f` multiplied by its derivative with
        respect to :math:`\psi` for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter**2 * tesla**2 * radian / weber]
        """
        return self._ff_prime_psi_spline(self.psi(psi_n))

    def f_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative of the poloidal current function :math:`f` with respect to
        :math:`\psi` for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * tesla * radian / weber]
        """
        return self.ff_prime(psi_n) / self.f(psi_n)

    @units.wraps(eq_units["p"], (None, units.dimensionless), strict=False)
    def p(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return plasma pressure for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [pascal]
        """
        return self._p_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["p_prime"], (None, units.dimensionless), strict=False)
    def p_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative of the plasma pressure with respect to :math:`\psi` for a
        given normalised poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [pascal * radian / weber]
        """
        return self._p_prime_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["q"], (None, units.dimensionless), strict=False)
    def q(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the safety factor for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [dimensionless]
        """
        return self._q_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["q_prime"], (None, units.dimensionless), strict=False)
    def q_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the derivative of the safety factor with respect to :math:`\psi` for a
        given normalised poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [radian / weber]
        """
        return self._q_psi_spline(self.psi(psi_n), nu=1)

    @units.wraps(eq_units["len"], (None, units.dimensionless), strict=False)
    def r_major(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the major radius position of the midpoint of the flux surface represented
        by a given normalised poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter]
        """
        return self._r_major_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["len_prime"], (None, units.dimensionless), strict=False)
    def r_major_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative with respect to :math:`\psi` of the major radius position of
        the midpoint of the flux surface represented by a given normalised poloidal
        magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * radian / weber]
        """
        return self._r_major_psi_spline(self.psi(psi_n), nu=1)

    @units.wraps(eq_units["len"], (None, units.dimensionless), strict=False)
    def r_minor(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return half of the width of the flux surface represented by a given normalised
        poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter]
        """
        return self._r_minor_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["len_prime"], (None, units.dimensionless), strict=False)
    def r_minor_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative with respect to :math:`\psi` of the width of the flux surface
        represented by a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * radian / weber]
        """
        return self._r_minor_psi_spline(self.psi(psi_n), nu=1)

    @units.wraps(eq_units["len"], (None, units.dimensionless), strict=False)
    def z_mid(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the vertical position of the midpoint of the flux surface represented by
        a given normalised poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter]
        """
        return self._z_mid_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["len_prime"], (None, units.dimensionless), strict=False)
    def z_mid_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the derivative with respect to :math:`\psi` of the vertical position of
        the midpoint of the flux surface represented by a given normalised poloidal
        magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * radian / weber]
        """
        return self._z_mid_psi_spline(self.psi(psi_n), nu=1)

    def rho(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the normalised minor radius of the flux surface represented by a given
        normalised poloidal magnetic flux function :math:`\psi_n`. This is the same as
        ``r_minor/a_minor``.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [dimensionless]
        """
        return self.r_minor(psi_n) / self.a_minor

    @units.wraps(eq_units["b"], (None, eq_units["len"], eq_units["len"]), strict=False)
    def br(self, r: ArrayLike, z: ArrayLike) -> np.ndarray:
        r"""
        Return the radial magnetic flux density at the position(s) ``(r, z)``.

        Parameters
        ----------
        r: ArrayLike, units [meter]
            Major radius positions.
        z: ArrayLike, units [meter]
            Vertical positions. Should have the same shape as ``r``, or be broadcastable
            to ``r``.

        Returns
        -------
        np.ndarray, units [tesla]
        """
        r = np.asanyarray(r) * eq_units["len"]
        z = np.asanyarray(z) * eq_units["len"]
        return -self._psi_rz_spline(r, z, dy=1, grid=False) / r

    @units.wraps(eq_units["b"], (None, eq_units["len"], eq_units["len"]), strict=False)
    def bz(self, r: ArrayLike, z: ArrayLike) -> np.ndarray:
        r"""
        Return the vertical magnetic flux density at the position(s) ``(r, z)``.

        Parameters
        ----------
        r: ArrayLike, units [meter]
            Major radius positions.
        z: ArrayLike, units [meter]
            Vertical positions. Should have the same shape as ``r``, or be broadcastable
            to ``r``.

        Returns
        -------
        np.ndarray, units [tesla]
        """
        r = np.asanyarray(r) * eq_units["len"]
        z = np.asanyarray(z) * eq_units["len"]
        return self._psi_rz_spline(r, z, dx=1, grid=False) / r

    @units.wraps(eq_units["b"], (None, eq_units["len"], eq_units["len"]), strict=False)
    def bp(self, r: ArrayLike, z: ArrayLike) -> np.ndarray:
        r"""
        Return the magnitude of the polooidal magnetic flux density at the position(s)
        ``(r, z)``.

        Parameters
        ----------
        r: ArrayLike, units [meter]
            Major radius positions.
        z: ArrayLike, units [meter]
            Vertical positions. Should have the same shape as ``r``, or be broadcastable
            to ``r``.

        Returns
        -------
        np.ndarray, units [tesla]
        """
        return np.hypot(self.br(r, z), self.bz(r, z))

    @units.wraps(eq_units["b"], (None, eq_units["len"], eq_units["len"]), strict=False)
    def bt(self, r: ArrayLike, z: ArrayLike) -> np.ndarray:
        r"""
        Return the toroidal magnetic flux density at the position(s) ``(r, z)``.

        Parameters
        ----------
        r: ArrayLike, units [meter]
            Major radius positions.
        z: ArrayLike, units [meter]
            Vertical positions. Should have the same shape as ``r``, or be broadcastable
            to ``r``.

        Returns
        -------
        np.ndarray, units [tesla]
        """
        r = np.asanyarray(r) * eq_units["len"]
        z = np.asanyarray(z) * eq_units["len"]
        # Get psi along the path, use this to get f
        psi = self._psi_rz_spline(r, z, grid=False)
        return self.f(self.psi_n(psi)) / r

    def flux_surface(self, psi_n: float) -> FluxSurface:
        r"""
        Generate a FluxSurface object representing the flux surface with normalised
        poloidal magnetic flux function :math:`\psi_n`. This Dataset-like object
        contains information such as the path swept out by the flux surface in
        ``(r_major, z)`` coordinates, the magnetic flux density along the path, and
        quantities such as pressure, safety factor, the poloidal current function
        :math:`f`, and their derivatives with respect to :math:`\psi` on the flux
        surface. It also contains derivatives with respect to the minor radius of
        the flux surface, and normalised versions of :math:`\psi`
        """
        # Get rz contours
        # (the 'wraps' decorator used by _flux_surface_contour does not recognise
        # xarray DataArrays)
        r, z = _flux_surface_contour(
            self["r"].data,
            self["z"].data,
            self["psi_rz"].data,
            self.r_axis,
            self.z_axis,
            self.psi(psi_n),
        )

        # Get magnetic field quantities around the contour path
        br = self.br(r, z)
        bz = self.bz(r, z)
        bt = self.bt(r, z)

        return FluxSurface(
            r=r,
            z=z,
            br=br,
            bz=bz,
            bt=bt,
            f=self.f(psi_n),
            f_prime=self.f_prime(psi_n),
            p=self.p(psi_n),
            p_prime=self.p_prime(psi_n),
            q=self.q(psi_n),
            q_prime=self.q_prime(psi_n),
            r_major=self.r_major(psi_n),
            r_major_prime=self.r_major_prime(psi_n),
            r_minor=self.r_minor(psi_n),
            r_minor_prime=self.r_minor_prime(psi_n),
            z_mid=self.z_mid(psi_n),
            z_mid_prime=self.z_mid_prime(psi_n),
            psi_axis=self.psi_axis,
            psi_lcfs=self.psi_lcfs,
            a_minor=self.a_minor,
        )

    def __deepcopy__(self, memodict):
        """Copy Equilibrium object in full, following references down the stack."""
        # Create new object without calling __init__
        new_equilibrium = Equilibrium.__new__(Equilibrium)
        # Deep copy each member individually
        for key, value in vars(self).items():
            setattr(new_equilibrium, key, deepcopy(value, memodict))
        return new_equilibrium


# Create global instance of reader factory
_equilibrium_readers = create_reader_factory()


def equilibrium_reader(key: str) -> None:
    r"""
    Decorator for classes that inherit Reader and create Equilibrium objects. Registers
    classes with the global factory, and sets the class-level attribute 'file_type'
    to the provided key. Can be used to register user-created plugins for equilibrium
    file readers.

    Examples
    --------

    ::

        # Use this to decorate classes which inherit Reader and define the functions
        # 'read' and (optionally) 'verify'. Provide a key that will be used as an
        # identifier.
        @equilibrium_reader("MyEquilibrium")
        class MyEquilibriumReader(Reader):

            def read(self, path):
                pass

            def verify(self, path):
                pass

        # MyEquilibriumReader will now contain the 'file_type' attribute
        assert MyEquilibriumReader.file_type == "MyEquilibrium"

        # The user can now read files of this type
        eq = read_equilibrium("MyEquilibrium.txt", eq_type="MyEquilibrium")
    """

    def decorator(cls: Type[Reader]):
        _equilibrium_readers[key] = cls
        cls.file_type = key
        return cls

    return decorator


def read_equilibrium(
    path: PathLike,
    eq_type: Optional[str] = None,
    **kwargs,
) -> Equilibrium:
    r"""
    Read a plasma equilibrium file from disk, returning an ``Equilibrium`` instance.

    Parameters
    ----------
    path: PathLike
        Location of the equilibrium file on disk.
    eq_type: Optional[str]
        String specifying the type of equilibrium file. If unset, the file type will be
        inferred automatically. Specifying the file type may improve performance.
    **kwargs:
        Keyword arguments forwarded to the equilibrium file reader.

    Returns
    -------
    Equilibrium

    Raises
    ------
    ValueError
        If ``path`` does not refer to a valid file.
    RuntimeError
        If ``eq_type`` is unset, and it is not possible to infer the file type
        automatically.
    """
    path = Path(path)
    if not path.is_file():
        raise ValueError(f"File {path} not found.")
    # Infer reader type from path if not provided with eq_type
    reader = _equilibrium_readers[path if eq_type is None else eq_type]
    return reader(path, **kwargs)


def supported_equilibrium_types() -> List[str]:
    """Returns a list of supported equilibrium file types."""
    return [*_equilibrium_readers]
