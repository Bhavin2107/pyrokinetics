from __future__ import annotations  # noqa
from copy import deepcopy
from typing import Type, Optional, List, Callable
from pathlib import Path
from textwrap import dedent
import warnings

import numpy as np
from numpy.typing import ArrayLike
import xarray as xr
import matplotlib.pyplot as plt

from pyrokinetics.dataset_wrapper import DatasetWrapper
from pyrokinetics.readers import Reader, create_reader_factory
from pyrokinetics.typing import PathLike
from pyrokinetics.units import ureg as units
from pyrokinetics._version import __version__
from .flux_surface import _flux_surface_contour, FluxSurface
from .utils import eq_units, UnitSpline, UnitSpline2D


class Equilibrium(DatasetWrapper):
    r"""
    Contains a solution of the Grad-Shafranov equation, which defines a tokamak plasma
    equilibrium. Users are not expected to initialise ``Equilibrium`` objects directly,
    and in most cases should instead make use of the function ``read_equilibrium``,
    which can read popular plasma equilibrium file types such as GEQDSK, generated by
    tools such as FreeGS_ and EFIT_, or netCDF4 files generated by TRANSP_ or VMEC_.
    Follows the convention COCOS 1.

    .. _FreeGS: https://github.com/freegs-plasma/freegs
    .. _EFIT: https://omfit.io/modules/mod_EFIT++.html
    .. _TRANSP: https://transp.pppl.gov/
    .. _VMEC: https://princetonuniversity.github.io/STELLOPT/VMEC

    Parameters
    ----------

    R: ArrayLike, units [meter]
        Linearly spaced and monotonically increasing 1D grid of major radius
        coordinates. This is the radius from the central column of a tokamak, and not
        the radial distance from the magnetic axis.
    Z: ArrayLike, units [meter]
        Linearly spaced and monotonically increasing 1D grid of tokamak z-coordinates.
        This is usually the height above the plasma midplane, but z=0 may be set at any
        reference point.
    psi_RZ: ArrayLike, units [webers / radian]
        2D grid defining the poloidal magnetic flux function :math::`\psi` with respect
        to ``R`` and ``Z``. Should have the shape ``(len(r), len(z))``.
    psi: ArrayLike, units [weber / radian]
        Monotonically increasing 1D grid defining the poloidal magnetic flux function.
        This grid defines magnetic flux surface coordinates, on which most other
        parameters are defined. ``psi[0]`` should be the value of ``psi`` on the
        magnetic axis.
    f: ArrayLike, units [meter * tesla]
        1D grid defining the poloidal current function with respect to ``psi``. Should
        have the same length as ``psi``.
    ff_prime: ArrayLike, units [meter**2 * tesla**2 * radian / weber]
        1D grid defining the poloidal current function ``f`` multiplied by its
        derivative with respect to ``psi``. Should have the same length as ``psi``.
    p: ArrayLike, units [pascal]
        1D grid defining the plasma pressure with respect to ``psi``. Should have the
        same length as ``psi``.
    p_prime: ArrayLike, units [pascal * radian / weber]
        1D grid defining the derivative of the plasma pressure with respect to ``psi``.
        Should have the same length as ``psi``.
    q: ArrayLike, units [dimensionless]
        1D grid defining the 'safety factor' with respect to ``psi``. Should have same
        length as ``psi``.
    R_major: ArrayLike, units [meter]
        1D grid of the major radius positions of the center of each flux surface with
        respect to ``psi``. Should have the same length as ``psi``. This should be given
        by the mean of the maximum and minimum major radii of the flux surface.
        ``R_major[0]`` should be the major radius of the magnetic axis.
    r_minor: ArrayLike, units[meter]
        1D grid of the minor radius of each flux surface with respect to ``psi``. Should
        have the same length as ``psi``. This should be half of the difference between
        the maximum and minimum major radii of a flux surface. ``r_minor[0]`` should be
        0.0.
    Z_mid: ArrayLike, units [meter]
        1D grid of the z-midpoint of each flux surface with respace to ``psi``. Should
        have the same length as ``psi``. This should be the mean of the maximum and
        minimum z-positions of the flux surface. ``Z_mid[0]`` should be the z-position
        of the magnetic axis.
    psi_lcfs: float, units [weber / radian]
        The value of ``psi`` on the last closed flux surface (LCFS).
    a_minor: float, units [meter]
        The minor radius of the last closed flux surface (LCFS). The minor radius of a
        flux surface is half of the difference between its maximum and minimum major
        radii.
    eq_type: Optional[str]
        A label denoting the type of Equilibrium, such as "GEQDSK", "TRANSP", "VMEC",
        etc.

    Attributes
    ----------

    data: xarray.Dataset
        The internal representation of the ``Equilibrium`` object. The functions
        ``__getattr__`` and ``__getitem__`` redirect most attribute/indexing lookups
        here, but the Dataset itself may be accessed directly by the user if they wish
        to perform more complex manipulations.
    R_axis: float, units [meter]
        Major radius position of the magnetic axis.
    Z_axis: float, units [meter]
        Vertical position of the magnetic axis, in meters.
    psi_axis: float, units [weber / radian]
        Poloidal magnetic flux function :math:`\psi` on the magnetic axis.
    psi_lcfs: float, units [weber / radian]
        Poloidal magnetic flux function :math:`\psi` on the last closed flux surface.
    a_minor: float, units [meter]
        Minor radius of the last closed flux surface.
    dR: float, units [meter]
        Grid spacing in the radial direction.
    dZ: float, units [meter]
        Grid spacing in the vertical direction.
    eq_type: str
        Type of equilibrium.

    See Also
    --------
    read_equilibrium: Create ``Equilibrium`` from a file.
    FluxSurface: An individual flux surface created from an ``Equilibrium``.

    Notes
    -----

    The Grad-Shafranov equation [1]_ may be written:

    .. math::
        \frac{\partial^2 \psi}{\partial r^2}
        - \frac{1}{r}\frac{\partial\psi}{\partial r}
        + \frac{\partial^2 \psi}{\partial z^2}
        = -\mu_0 r^2 p'(\psi) - f(\psi)f'(\psi)

    The :math:`r` coordinate is the major radius, the distance from the central column
    of a tokamak, and :math:`z` is the height within the tokamak (often defined as the
    vertical distance about the tokamak midplane, but other reference points may be used
    instead).

    :math:`\psi` is the poloidal magnetic flux function, defined as:

    .. math::
        \vec{B_p} = \frac{1}{r} \nabla\psi \times \hat{\phi}

    where :math:`\vec{B_p}` is the poloidal magnetic field vector, and
    :math:`\hat{\phi}` is the unit vector in the toroidal direction. :math:`\psi` is
    arbitrary to within an additive constant. :math:`f` is the poloidal current
    function, and is defined similarly:

    .. math::
        \vec{J_p} = \frac{\mu_0}{r} \nabla f \times \hat{\phi}

    where :math:`\vec{J_p}` is the poloidal current density. It may be shown that
    :math:`f` is a function of :math:`\psi` only, as is the plasma pressure, :math:`p`.
    Along with the safety factor, :math:`q(\psi)`:

    .. math::
        q = \frac{1}{2\pi}\oint \frac{1}{r} \frac{B_\phi}{B_p} ds

    which describes the number of times a magnetic field line wraps around the toroidal
    direction before arriving at the same point in the poloidal plane, these quantities
    describe a plasma equilibrium in full.

    For gyrokinetics simulations, it is common for researchers to make use of the
    normalised :math:`\psi_n`, which is scaled so that :math:`\psi_n=0` at the magnetic
    axis, and :math:`\psi_n=1` at the Last Closed Flux Surface (LCFS).

    .. [1] J. Wesson and D.J. Campbell: "Tokamaks", Oxford University Press, 2011,
        chapter 3
    """

    _init_units = {
        "self": None,
        "R": eq_units["len"],
        "Z": eq_units["len"],
        "psi_RZ": eq_units["psi"],
        "psi": eq_units["psi"],
        "f": eq_units["f"],
        "ff_prime": eq_units["ff_prime"],
        "p": eq_units["p"],
        "p_prime": eq_units["p_prime"],
        "q": eq_units["q"],
        "R_major": eq_units["len"],
        "r_minor": eq_units["len"],
        "Z_mid": eq_units["len"],
        "psi_lcfs": eq_units["psi"],
        "a_minor": eq_units["len"],
        "eq_type": None,
    }

    @units.wraps(None, [*_init_units.values()], strict=False)
    def __init__(
        self,
        R: ArrayLike,
        Z: ArrayLike,
        psi_RZ: ArrayLike,
        psi: ArrayLike,
        f: ArrayLike,
        ff_prime: ArrayLike,
        p: ArrayLike,
        p_prime: ArrayLike,
        q: ArrayLike,
        R_major: ArrayLike,
        r_minor: ArrayLike,
        Z_mid: ArrayLike,
        psi_lcfs: float,
        a_minor: float,
        eq_type: Optional[str] = None,
    ) -> None:
        # Check the grids R, Z, and psi_RZ
        R = np.asanyarray(R, dtype=float) * eq_units["len"]
        Z = np.asanyarray(Z, dtype=float) * eq_units["len"]
        psi_RZ = np.asanyarray(psi_RZ, dtype=float) * eq_units["psi"]
        # Check that r and z are linearly spaced and increasing 1D grids
        for name, grid in {"R": R, "Z": Z}.items():
            if len(grid.shape) != 1:
                raise ValueError(f"The grid {name} must be 1D.")
            diff = np.diff(grid)
            if not np.allclose(diff, diff[0]):
                raise ValueError(f"The grid {name} must linearly spaced.")
            if diff[0] <= 0.0:
                raise ValueError(f"The grid {name} must have a positive spacing.")
        # Check that psi_RZ has the correct dimensions
        shape_2d = (len(R), len(Z))
        if not np.array_equal(psi_RZ.shape, shape_2d):
            raise ValueError(
                f"The grid psi_RZ has shape {psi_RZ.shape}. "
                f"It should have shape {shape_2d}."
            )

        # Create bivariate spline and partial derivatives over psi_RZ
        self._psi_RZ_spline = UnitSpline2D(R, Z, psi_RZ)

        # Check the psi grids
        psi = np.asanyarray(psi, dtype=float) * eq_units["psi"]
        f = np.asanyarray(f, dtype=float) * eq_units["f"]
        ff_prime = np.asanyarray(ff_prime, dtype=float) * eq_units["ff_prime"]
        p = np.asanyarray(p, dtype=float) * eq_units["p"]
        p_prime = np.asanyarray(p_prime, dtype=float) * eq_units["p_prime"]
        q = np.asanyarray(q, dtype=float) * eq_units["q"]
        R_major = np.asanyarray(R_major, dtype=float) * eq_units["len"]
        r_minor = np.asanyarray(r_minor, dtype=float) * eq_units["len"]
        Z_mid = np.asanyarray(Z_mid, dtype=float) * eq_units["len"]
        # Ensure psi is 1D and monotonically increasing
        if len(psi.shape) != 1:
            raise ValueError("The grid psi must be 1D.")
        if np.any(np.diff(psi) <= 0):
            raise ValueError("The grid psi must have a positive spacing.")
        # Ensure all psi grids have the correct shape
        psi_grids = {
            "f": f,
            "ff_prime": ff_prime,
            "p": p,
            "p_prime": p_prime,
            "q": q,
            "R_major": R_major,
            "r_minor": r_minor,
            "Z_mid": Z_mid,
        }
        psi_shape = psi.shape
        for name, grid in psi_grids.items():
            if not np.array_equal(grid.shape, psi_shape):
                raise ValueError(
                    f"The grid {name} has shape {grid.shape}. "
                    f"It should have shape {psi_shape}."
                )

        # Check that floats are valid
        psi_lcfs = float(psi_lcfs) * eq_units["psi"]
        if psi_lcfs < psi[0]:
            raise ValueError("psi_lcfs should be greater than psi[0].")
        a_minor = float(a_minor) * eq_units["len"]
        if a_minor <= 0.0:
            raise ValueError("a_minor should be a positive float.")

        # Check r_minor and create normalised version 'rho'
        if r_minor[0] != 0.0:
            raise ValueError("r_minor[0] should be zero.")
        if np.any(np.diff(r_minor) <= 0):
            raise ValueError("The grid r_minor must have a positive spacing.")
        rho = r_minor / a_minor

        # Create normalised 1d psi grid
        psi_n = (psi - psi[0]) / (psi_lcfs - psi[0])

        # Create spline functions for all psi grids with respect to psi
        self._f_psi_spline = UnitSpline(psi, f)
        self._ff_prime_psi_spline = UnitSpline(psi, ff_prime)
        self._p_psi_spline = UnitSpline(psi, p)
        self._p_prime_psi_spline = UnitSpline(psi, p_prime)
        self._q_psi_spline = UnitSpline(psi, q)
        self._R_major_psi_spline = UnitSpline(psi, R_major)
        self._r_minor_psi_spline = UnitSpline(psi, r_minor)
        self._Z_mid_psi_spline = UnitSpline(psi, Z_mid)

        # Assemble grids into underlying xarray Dataset
        def make_var(dim, val, desc):
            return (dim, val, {"units": str(val.units), "long_name": desc})

        coords = {
            "R": make_var("R_dim", R, "R Major Position"),
            "Z": make_var("Z_dim", Z, "Vertical Position"),
            "psi": make_var("psi_dim", psi, "Poloidal Flux"),
        }

        data_vars = {
            "psi_RZ": make_var(("R_dim", "Z_dim"), psi_RZ, "Poloidal Flux"),
            "f": make_var("psi_dim", f, "Poloidal Current"),
            "ff_prime": make_var("psi_dim", ff_prime, "ff'"),
            "p": make_var("psi_dim", p, "Plasma Pressure"),
            "p_prime": make_var("psi_dim", p_prime, "p'(psi)"),
            "q": make_var("psi_dim", q, "Safety Factor"),
            "R_major": make_var("psi_dim", R_major, "Flux Surface Radial Midpoint"),
            "r_minor": make_var("psi_dim", r_minor, "Flux Surface Width"),
            "Z_mid": make_var("psi_dim", Z_mid, "Flux Surface Vertical Midpoint"),
            "rho": make_var("psi_dim", rho, "Normalised Flux Surface Width"),
            "psi_n": make_var("psi_dim", psi_n, "Normalised Poloidal Flux"),
        }

        attrs = {
            "R_axis": R_major[0],
            "Z_axis": Z_mid[0],
            "psi_axis": psi[0],
            "psi_lcfs": psi_lcfs,
            "a_minor": a_minor,
            "dR": R[1] - R[0],
            "dZ": Z[1] - Z[0],
            "eq_type": str(eq_type),
        }

        super().__init__(data_vars=data_vars, coords=coords, attrs=attrs)

    @units.wraps(eq_units["psi"], (None, units.dimensionless), strict=False)
    def psi(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return actual poloidal magnetic flux function :math:`\psi` for a given
        normalised :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]
            Normalised poloidal magnetic flux function, scaled such that
            :math:`\psi_n=0` on the magnetic axis and :math:`\psi_n=1` on the last
            closed flux surface. Results are undefined outside this range.

        Returns
        -------
        np.ndarray, units [weber / radian]
            Actual poloidal magnetic flux. Note that the result is arbitrary within an
            additive constant.
        """
        # units introduced via self.psi_axis and self.psi_lcfs
        return self.psi_axis + np.asanyarray(psi_n) * (self.psi_lcfs - self.psi_axis)

    @units.wraps(units.dimensionless, (None, eq_units["psi"]), strict=False)
    def psi_n(self, psi: ArrayLike) -> np.ndarray:
        r"""
        Return normalised poloidal magnetic flux function :math:`\psi_n` for a given
        actual :math:`\psi`.

        Parameters
        ----------
        psi: ArrayLike, units [weber / radian]
            Actual poloidal magnetic flux. Note that the result is arbitrary within an
            additive constant.

        Returns
        -------
        np.ndarray, units [dimensionless]
            Normalised poloidal magnetic flux function, scaled such that
            :math:`\psi_n=0` on the magnetic axis and :math:`\psi_n=1` on the last
            closed flux surface. Results are undefined outside this range.
        """
        psi = np.asanyarray(psi) * eq_units["psi"]
        return (psi - self.psi_axis) / (self.psi_lcfs - self.psi_axis)

    @units.wraps(eq_units["f"], (None, units.dimensionless), strict=False)
    def f(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return poloidal current function :math:`f` at the normalised poloidal magnetic
        flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * tesla]
        """
        return self._f_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["ff_prime"], (None, units.dimensionless), strict=False)
    def ff_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return poloidal current function :math:`f` multiplied by its derivative with
        respect to :math:`\psi` for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter**2 * tesla**2 * radian / weber]
        """
        return self._ff_prime_psi_spline(self.psi(psi_n))

    def f_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative of the poloidal current function :math:`f` with respect to
        :math:`\psi` for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * tesla * radian / weber]
        """
        return self.ff_prime(psi_n) / self.f(psi_n)

    @units.wraps(eq_units["p"], (None, units.dimensionless), strict=False)
    def p(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return plasma pressure for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [pascal]
        """
        return self._p_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["p_prime"], (None, units.dimensionless), strict=False)
    def p_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative of the plasma pressure with respect to :math:`\psi` for a
        given normalised poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [pascal * radian / weber]
        """
        return self._p_prime_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["q"], (None, units.dimensionless), strict=False)
    def q(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the safety factor for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [dimensionless]
        """
        return self._q_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["q_prime"], (None, units.dimensionless), strict=False)
    def q_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the derivative of the safety factor with respect to :math:`\psi` for a
        given normalised poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [radian / weber]
        """
        return self._q_psi_spline(self.psi(psi_n), derivative=1)

    @units.wraps(eq_units["len"], (None, units.dimensionless), strict=False)
    def R_major(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the major radius position of the midpoint of the flux surface represented
        by a given normalised poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter]
        """
        return self._R_major_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["len_prime"], (None, units.dimensionless), strict=False)
    def R_major_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative with respect to :math:`\psi` of the major radius position of
        the midpoint of the flux surface represented by a given normalised poloidal
        magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * radian / weber]
        """
        return self._R_major_psi_spline(self.psi(psi_n), derivative=1)

    @units.wraps(eq_units["len"], (None, units.dimensionless), strict=False)
    def r_minor(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return half of the width of the flux surface represented by a given normalised
        poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter]
        """
        return self._r_minor_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["len_prime"], (None, units.dimensionless), strict=False)
    def r_minor_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative with respect to :math:`\psi` of the width of the flux surface
        represented by a given normalised poloidal magnetic flux function
        :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * radian / weber]
        """
        return self._r_minor_psi_spline(self.psi(psi_n), derivative=1)

    @units.wraps(eq_units["len"], (None, units.dimensionless), strict=False)
    def Z_mid(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the vertical position of the midpoint of the flux surface represented by
        a given normalised poloidal magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter]
        """
        return self._Z_mid_psi_spline(self.psi(psi_n))

    @units.wraps(eq_units["len_prime"], (None, units.dimensionless), strict=False)
    def Z_mid_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the derivative with respect to :math:`\psi` of the vertical position of
        the midpoint of the flux surface represented by a given normalised poloidal
        magnetic flux function :math:`\psi_n`.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [meter * radian / weber]
        """
        return self._Z_mid_psi_spline(self.psi(psi_n), derivative=1)

    def rho(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the normalised minor radius of the flux surface represented by a given
        normalised poloidal magnetic flux function :math:`\psi_n`. This is the same as
        ``r_minor/a_minor``.

        Parameters
        ----------
        psi_n: ArrayLike, units [dimensionless]

        Returns
        -------
        np.ndarray, units [dimensionless]
        """
        return self.r_minor(psi_n) / self.a_minor

    @units.wraps(eq_units["b"], (None, eq_units["len"], eq_units["len"]), strict=False)
    def b_radial(self, R: ArrayLike, Z: ArrayLike) -> np.ndarray:
        r"""
        Return the radial magnetic flux density at the position(s) ``(R, Z)``.

        Parameters
        ----------
        R: ArrayLike, units [meter]
            Major radius positions.
        Z: ArrayLike, units [meter]
            Vertical positions. Should have the same shape as ``R``, or be broadcastable
            to ``R``.

        Returns
        -------
        np.ndarray, units [tesla]
        """
        R = np.asanyarray(R) * eq_units["len"]
        Z = np.asanyarray(Z) * eq_units["len"]
        return -self._psi_RZ_spline(R, Z, dy=1) / R

    @units.wraps(eq_units["b"], (None, eq_units["len"], eq_units["len"]), strict=False)
    def b_vertical(self, R: ArrayLike, Z: ArrayLike) -> np.ndarray:
        r"""
        Return the vertical magnetic flux density at the position(s) ``(R, Z)``.

        Parameters
        ----------
        R: ArrayLike, units [meter]
            Major radius positions.
        Z: ArrayLike, units [meter]
            Vertical positions. Should have the same shape as ``R``, or be broadcastable
            to ``R``.

        Returns
        -------
        np.ndarray, units [tesla]
        """
        R = np.asanyarray(R) * eq_units["len"]
        Z = np.asanyarray(Z) * eq_units["len"]
        return self._psi_RZ_spline(R, Z, dx=1) / R

    @units.wraps(eq_units["b"], (None, eq_units["len"], eq_units["len"]), strict=False)
    def b_poloidal(self, R: ArrayLike, Z: ArrayLike) -> np.ndarray:
        r"""
        Return the magnitude of the polooidal magnetic flux density at the position(s)
        ``(R, Z)``.

        Parameters
        ----------
        R: ArrayLike, units [meter]
            Major radius positions.
        Z: ArrayLike, units [meter]
            Vertical positions. Should have the same shape as ``R``, or be broadcastable
            to ``R``.

        Returns
        -------
        np.ndarray, units [tesla]
        """
        return np.hypot(self.b_radial(R, Z), self.b_vertical(R, Z))

    @units.wraps(eq_units["b"], (None, eq_units["len"], eq_units["len"]), strict=False)
    def b_toroidal(self, R: ArrayLike, Z: ArrayLike) -> np.ndarray:
        r"""
        Return the toroidal magnetic flux density at the position(s) ``(R, Z)``.

        Parameters
        ----------
        R: ArrayLike, units [meter]
            Major radius positions.
        Z: ArrayLike, units [meter]
            Vertical positions. Should have the same shape as ``R``, or be broadcastable
            to ``R``.

        Returns
        -------
        np.ndarray, units [tesla]
        """
        R = np.asanyarray(R) * eq_units["len"]
        Z = np.asanyarray(Z) * eq_units["len"]
        # Get psi along the path, use this to get f
        psi = self._psi_RZ_spline(R, Z)
        return self.f(self.psi_n(psi)) / R

    def flux_surface(self, psi_n: float) -> FluxSurface:
        r"""
        Generate a FluxSurface object representing the flux surface with normalised
        poloidal magnetic flux function :math:`\psi_n`. This Dataset-like object
        contains information such as the path swept out by the flux surface in
        ``(R, z)`` coordinates, the magnetic flux density along the path, and
        quantities such as pressure, safety factor, the poloidal current function
        :math:`f`, and their derivatives with respect to :math:`\psi` on the flux
        surface. It also contains derivatives with respect to the minor radius of
        the flux surface, and normalised versions of :math:`\psi`
        """
        # Get rz contours
        # (the 'wraps' decorator used by _flux_surface_contour does not recognise
        # xarray DataArrays)
        R, Z = _flux_surface_contour(
            self["R"].data,
            self["Z"].data,
            self["psi_RZ"].data,
            self.R_axis,
            self.Z_axis,
            self.psi(psi_n),
        )

        # Get magnetic field quantities around the contour path
        b_radial = self.b_radial(R, Z)
        b_vertical = self.b_vertical(R, Z)
        b_toroidal = self.b_toroidal(R, Z)

        return FluxSurface(
            R=R,
            Z=Z,
            b_radial=b_radial,
            b_vertical=b_vertical,
            b_toroidal=b_toroidal,
            psi=self.psi(psi_n),
            f=self.f(psi_n),
            f_prime=self.f_prime(psi_n),
            p=self.p(psi_n),
            p_prime=self.p_prime(psi_n),
            q=self.q(psi_n),
            q_prime=self.q_prime(psi_n),
            R_major=self.R_major(psi_n),
            R_major_prime=self.R_major_prime(psi_n),
            r_minor=self.r_minor(psi_n),
            r_minor_prime=self.r_minor_prime(psi_n),
            Z_mid=self.Z_mid(psi_n),
            Z_mid_prime=self.Z_mid_prime(psi_n),
            psi_axis=self.psi_axis,
            psi_lcfs=self.psi_lcfs,
            a_minor=self.a_minor,
        )

    def plot(
        self,
        quantity: str,
        ax: Optional[plt.Axes] = None,
        psi_n: bool = False,
        show: bool = False,
        x_label: Optional[str] = None,
        y_label: Optional[str] = None,
        **kwargs,
    ) -> plt.Axes:
        r"""
        Plot a quantity defined on the :math:`\psi` grid.

        Parameters
        ----------
        quantity: str
            Name of the quantity to plot. Must be defined over the grid ``psi``.
        ax: Optional[plt.Axes]
            Axes object on which to plot. If not provided, a new figure is created.
        psi_n: bool, default False
            If True, plot against normalised :math:`\psi_n`. Otherwise, plot against
            :math:`\psi`.
        show: bool, default False
            Immediately show Figure after creation.
        x_label: Optional[str], default None
            Overwrite the default x label. Set to an empty string ``""`` to disable.
        y_label: Optional[str], default None
            Overwrite the default y label. Set to an empty string ``""`` to disable.
        **kwargs
            Additional arguments to pass to Matplotlib's ``plot`` call.

        Returns
        -------
        plt.Axes
            The Axes object created after plotting.

        Raises
        ------
        ValueError
            If ``quantity`` is not a quantity defined over the :math:`\psi` grid,
            or is not the name of an Equilibrium quantity.
        """
        if quantity not in self.data_vars:
            raise ValueError(
                f"Must be provided with a quantity defined on the psi grid."
                f"The quantity '{quantity}' is not recognised."
            )

        quantity_dims = self[quantity].dims
        if "psi_dim" not in quantity_dims or len(quantity_dims) != 1:
            raise ValueError(
                f"Must be provided with a quantity defined on the psi grid."
                f"The quantity '{quantity}' has coordinates {quantity_dims}."
            )

        if ax is None:
            _, ax = plt.subplots(1, 1)

        x_data = self["psi_n" if psi_n else "psi"]
        if x_label is None:
            x_label = x_data.long_name
            if x_data.data.units != "":
                x_label += f" / ${x_data.data.units:L~}$"

        y_data = self[quantity]
        if y_label is None:
            y_label = y_data.long_name
            if y_data.data.units != "":
                y_label += f" / ${y_data.data.units:L~}$"

        ax.plot(x_data.data.magnitude, y_data.data.magnitude, **kwargs)
        if x_label != "":
            ax.set_xlabel(x_label)
        if y_label != "":
            ax.set_ylabel(y_label)

        if show:
            plt.show()

        return ax

    def contour(
        self,
        ax: Optional[plt.Axes] = None,
        cbar: bool = True,
        show: bool = False,
        x_label: Optional[str] = None,
        y_label: Optional[str] = None,
        z_label: Optional[str] = None,
        **kwargs,
    ) -> plt.Axes:
        r"""
        Plot :math:`\psi` over the :math:`(R, Z)` grid using a 2D coloured contour plot.
        Uses Matplotlib's ``contourf``.

        Parameters
        ----------
        ax: Optional[plt.Axes]
            Axes object on which to plot. If not provided, a new figure is created.
        cbar: bool, default True
            If True, builds a colourbar next to the generated plot.
        show: bool, default False
            Immediately show Figure after creation.
        x_label: Optional[str], default None
            Overwrite the default x label. Set to an empty string ``""`` to disable.
        y_label: Optional[str], default None
            Overwrite the default y label. Set to an empty string ``""`` to disable.
        z_label: Optional[str], default None
            Overwrite the default colorbar label. Set to an empty string ``""`` to
            disable. Ignored if ``cbar`` is False.
        **kwargs
            Additional arguments to pass to Matplotlib's ``contourf`` call.

        Returns
        -------
        plt.Axes
            The Axes object created after plotting.
        """

        if ax is None:
            _, ax = plt.subplots(1, 1)

        x_data = self["R"]
        if x_label is None:
            x_label = f"{x_data.long_name} / ${x_data.data.units:L~}$"

        y_data = self["Z"]
        if y_label is None:
            y_label = f"{y_data.long_name} / ${y_data.data.units:L~}$"

        z_data = self["psi_RZ"]
        if z_label is None:
            z_label = f"{z_data.long_name} / ${z_data.data.units:L~}$"

        x_grid, y_grid = np.meshgrid(
            x_data.data.magnitude, y_data.data.magnitude, indexing="ij"
        )

        im = ax.contourf(x_grid, y_grid, z_data.data.magnitude, **kwargs)
        ax.set_xlabel(x_label)
        ax.set_ylabel(y_label)

        if cbar:
            fig = ax.get_figure()
            colorbar = fig.colorbar(im, ax=ax)
            colorbar.set_label(z_label)

        if show:
            plt.show()

        return ax

    def __deepcopy__(self, memodict):
        """Copy Equilibrium object in full, following references down the stack."""
        # Create new object without calling __init__
        new_equilibrium = Equilibrium.__new__(Equilibrium)
        # Deep copy each member individually
        for key, value in vars(self).items():
            setattr(new_equilibrium, key, deepcopy(value, memodict))
        return new_equilibrium


# Create global instance of reader factory
_equilibrium_readers = create_reader_factory()


def equilibrium_reader(key: str) -> Callable:
    r"""
    Decorator for classes that inherit Reader and create Equilibrium objects. Registers
    classes with the global factory, and sets the class-level attribute 'file_type'
    to the provided key. Can be used to register user-created plugins for equilibrium
    file readers.

    Examples
    --------

    ::

        # Use this to decorate classes which inherit Reader and define the functions
        # 'read' and (optionally) 'verify'. Provide a key that will be used as an
        # identifier.
        @equilibrium_reader("MyEquilibrium")
        class MyEquilibriumReader(Reader):

            def read(self, path):
                pass

            def verify(self, path):
                pass

        # MyEquilibriumReader will now contain the 'file_type' attribute
        assert MyEquilibriumReader.file_type == "MyEquilibrium"

        # The user can now read files of this type
        eq = read_equilibrium("MyEquilibrium.txt", eq_type="MyEquilibrium")
    """

    def decorator(cls: Type[Reader]) -> Type[Reader]:
        _equilibrium_readers[key] = cls
        cls.file_type = key
        return cls

    return decorator


@equilibrium_reader("Pyrokinetics")
class EquilibriumReaderPyro(Reader):
    """
    An Equilibrium reader class for netcdf files generated from Pyrokinetics Equilibrium
    objects. These can be created using ``eq.to_netcdf("my_filename.nc")``.
    """

    def read(self, filename: PathLike, **kwargs) -> Equilibrium:
        self.verify(filename)
        eq = Equilibrium.from_netcdf(filename, **kwargs)
        if eq.software_version != __version__:
            warnings.warn(
                dedent(
                    f"""\
                    Pyrokinetics Equilibrium object {filename} may not be compatible.
                    It was created with version {eq.software_version}, while this is
                    version {__version__}.
                    """
                )
            )
        return eq

    def verify(self, filename: PathLike) -> None:
        ds = xr.open_dataset(filename)
        if ds.software_name != "Pyrokinetics":
            raise ValueError
        if ds.object_type != "Equilibrium":
            raise ValueError


def read_equilibrium(
    path: PathLike,
    eq_type: Optional[str] = None,
    **kwargs,
) -> Equilibrium:
    r"""
    Read a plasma equilibrium file from disk, returning an ``Equilibrium`` instance.

    Parameters
    ----------
    path: PathLike
        Location of the equilibrium file on disk.
    eq_type: Optional[str]
        String specifying the type of equilibrium file. If unset, the file type will be
        inferred automatically. Specifying the file type may improve performance.
    **kwargs:
        Keyword arguments forwarded to the equilibrium file reader.

    Returns
    -------
    Equilibrium

    Raises
    ------
    ValueError
        If ``path`` does not refer to a valid file.
    RuntimeError
        If ``eq_type`` is unset, and it is not possible to infer the file type
        automatically.
    """
    path = Path(path)
    if not path.is_file():
        raise ValueError(f"File {path} not found.")
    # Infer reader type from path if not provided with eq_type
    reader = _equilibrium_readers[path if eq_type is None else eq_type]
    return reader(path, **kwargs)


def supported_equilibrium_types() -> List[str]:
    """Returns a list of supported equilibrium file types."""
    return [*_equilibrium_readers]
