from __future__ import annotations  # noqa
from copy import deepcopy
from typing import Type, Optional, List
from pathlib import Path

import numpy as np
from numpy.typing import ArrayLike
from scipy.interpolate import (
    InterpolatedUnivariateSpline as spline,
    RectBivariateSpline as spline_2d,
)

from ..dataset_wrapper import DatasetWrapper
from ..readers import Reader, create_reader_factory
from ..typing import PathLike
from .flux_surface import _flux_surface_contour, FluxSurface


class Equilibrium(DatasetWrapper):
    r"""
    Contains a solution of the Grad-Shafranov equation, which defines a tokamak plasma
    equilibrium. Users are not expected to initialise ``Equilibrium`` objects directly,
    and in most cases should instead make use of the function ``read_equilibrium``,
    which can read popular plasma equilibrium file types such as GEQDSK, generated by
    tools such as FreeGS_ and EFIT_, or netCDF4 files generated by TRANSP_ or VMEC_.

    .. _FreeGS: https://github.com/freegs-plasma/freegs
    .. _EFIT: https://omfit.io/modules/mod_EFIT++.html
    .. _TRANSP: https://transp.pppl.gov/
    .. _VMEC: https://princetonuniversity.github.io/STELLOPT/VMEC

    Parameters
    ----------

    r: numpy.ndarray
        Linearly spaced and monotonically increasing 1D grid of major radius
        coordinates. This is the radius from the central column of a tokamak, and not
        the radial distance from the magnetic axis. Units are in meters.
    z: numpy.ndarray
        Linearly spaced and monotonically increasing 1D grid of tokamak z-coordinates.
        This is usually the height above the plasma midplane, but z=0 may be set at any
        reference point. Units are in meters.
    psi_rz: numpy.ndarray
        2D grid defining the poloidal magnetic flux function :math::`\psi` with respect
        to ``r`` and ``z``. Should have the shape ``(len(r), len(z))``. Units of Webers
        per radian.
    psi: numpy.ndarray
        Monotonically increasing 1D grid defining the poloidal magnetic flux function.
        Has units of Webers per radian. This grid defines magnetic flux surface
        coordinates, on which most other parameters are defined. ``psi[0]`` should be
        the value of ``psi`` on the magnetic axis.
    f: numpy.ndarray
        1D grid defining the poloidal current function with respect to ``psi``. Should
        have the same length as ``psi``. Units are meter-Teslas (mT).
    ff_prime: numpy.ndarray
        1D grid defining the poloidal current function ``f`` multiplied by its
        derivative with respect to ``psi``. Should have the same length as ``psi``.
        Units are Rad m^2 T^2/Wb, where 'Rad' is radians, 'm' is meters, 'T' is Teslas,
        and 'Wb' is Webers.
    p: numpy.ndarray
        1D grid defining the plasma pressure with respect to ``psi``. Should have the
        same length as ``psi``. Units are pascals.
    p_prime: numpy.ndarray
        1D grid defining the derivative of the plasma pressure with respect to ``psi``.
        Should have the same length as ``psi``. Units are pascal-radians per Weber.
    q: numpy.ndarray
        1D grid defining the 'safety factor' with respect to ``psi``. Should have same
        length as ``psi``. Has no units.
    r_major: numpy.ndarray
        1D grid of the major radius positions of the center of each flux surface with
        respect to ``psi``. Should have the same length as ``psi``. Units are in meters.
        This should be given by the mean of the maximum and minimum major radii of the
        flux surface. ``r_major[0]`` should be the major radius of the magnetic axis.
    r_minor: numpy.ndarray
        1D grid of the minor radius of each flux surface with respect to ``psi``. Should
        have the same length as ``psi``. Units are in meters. This should be half of the
        difference between the maximum and minimum major radii of a flux surface.
        ``r_minor[0]`` should be 0.0.
    z_mid: numpy.ndarray
        1D grid of the z-midpoint of each flux surface with respace to ``psi``. Should
        have the same length as ``psi``, with units in meters. This should be the mean
        of the maximum and minimum z-positions of the flux surface. ``z_mid[0]`` should
        be the z-position of the magnetic axis.
    psi_lcfs: float
        The value of ``psi`` on the last closed flux surface (LCFS), in units of Webers
        per radian.
    a_minor: float
        The minor radius of the last closed flux surface (LCFS), in units of meters. The
        minor radius of a flux surface is half of the difference between its maximum and
        minimum major radii.

    Attributes
    ----------

    data: xarray.Dataset
        The internal representation of the ``Equilibrium`` object. The functions
        ``__getattr__`` and ``__getitem__`` redirect most attribute/indexing lookups
        here, but the Dataset itself may be accessed directly by the user if they wish
        to perform more complex manipulations.
    r_axis: float
        Major radius position of the magnetic axis, in meters.
    z_axis: float
        Vertical position of the magnetic axis, in meters.
    psi_axis: float
        Poloidal magnetic flux function :math:`\psi` on the magnetic axis. Units are
        Webers per radian.
    psi_lcfs: float
        Poloidal magnetic flux function :math:`\psi` on the last closed flux surface.
        Units are Webers per radian.
    a_minor: float
        Minor radius of the last closed flux surface, in meters.
    dr: float
        Grid spacing in the radial direction, in meters.
    dz: float
        Grid spacing in the vertical direction, in meters.

    See Also
    --------
    read_equilibrium: Create ``Equilibrium`` from a file.
    FluxSurface: An individual flux surface created from an ``Equilibrium``.

    Notes
    -----

    The Grad-Shafranov equation [1]_ may be written:

    .. math::
        \frac{\partial^2 \psi}{\partial r^2}
        - \frac{1}{r}\frac{\partial\psi}{\partial r}
        + \frac{\partial^2 \psi}{\partial z^2}
        = -\mu_0 r^2 p'(\psi) - f(\psi)f'(\psi)

    The :math:`r` coordinate is the major radius, the distance from the central column
    of a tokamak, and :math:`z` is the height within the tokamak (often defined as the
    vertical distance about the tokamak midplane, but other reference points may be used
    instead).

    :math:`\psi` is the poloidal magnetic flux function, defined as:

    .. math::
        \vec{B_p} = \frac{1}{r} \nabla\psi \times \hat{\phi}

    where :math:`\vec{B_p}` is the poloidal magnetic field vector, and
    :math:`\hat{\phi}` is the unit vector in the toroidal direction. :math:`\psi` is
    arbitrary to within an additive constant. :math:`f` is the poloidal current
    function, and is defined similarly:

    .. math::
        \vec{J_p} = \frac{\mu_0}{r} \nabla f \times \hat{\phi}

    where :math:`\vec{J_p}` is the poloidal current density. It may be shown that
    :math:`f` is a function of :math:`\psi` only, as is the plasma pressure, :math:`p`.
    Along with the safety factor, :math:`q(\psi)`:

    .. math::
        q = \frac{1}{2\pi}\oint \frac{1}{r} \frac{B_\phi}{B_p} ds

    which describes the number of times a magnetic field line wraps around the toroidal
    direction before arriving at the same point in the poloidal plane, these quantities
    describe a plasma equilibrium in full.

    For gyrokinetics simulations, it is common for researchers to make use of the
    normalised :math:`\psi_n`, which is scaled so that :math:`\psi_n=0` at the magnetic
    axis, and :math:`\psi_n=1` at the Last Closed Flux Surface (LCFS).

    .. [1] J. Wesson and D.J. Campbell: "Tokamaks", Oxford University Press, 2011,
        chapter 3
    """

    def __init__(
        self,
        r: np.ndarray,
        z: np.ndarray,
        psi_rz: np.ndarray,
        psi: np.ndarray,
        f: np.ndarray,
        ff_prime: np.ndarray,
        p: np.ndarray,
        p_prime: np.ndarray,
        q: np.ndarray,
        r_major: np.ndarray,
        r_minor: np.ndarray,
        z_mid: np.ndarray,
        psi_lcfs: float,
        a_minor: float,
    ) -> None:
        # Check the grids r, z, and psi_rz
        r = np.asanyarray(r, dtype=float)
        z = np.asanyarray(z, dtype=float)
        psi_rz = np.asanyarray(psi_rz, dtype=float)
        # Check that r and z are linearly spaced and increasing 1D grids
        for name, grid in {"r": r, "z": z}.items():
            if len(grid.shape) != 1:
                raise ValueError(f"The grid {name} must be 1D.")
            diff = np.diff(grid)
            if not np.allclose(diff, diff[0]):
                raise ValueError(f"The grid {name} must linearly spaced.")
            if diff[0] <= 0.0:
                raise ValueError(f"The grid {name} must have a positive spacing.")
        # Check that psi_rz has the correct dimensions
        shape_2d = (len(r), len(z))
        if not np.array_equal(psi_rz.shape, shape_2d):
            raise ValueError(
                f"The grid psi_rz has shape {psi_rz.shape}. "
                f"It should have shape {shape_2d}."
            )

        # Create bivariate spline and partial derivatives over psi_rz
        self._psi_rz_spline = spline_2d(r, z, psi_rz)
        self._dpsi_dr_spline = self._psi_rz_spline.partial_derivative(1, 0)
        self._dpsi_dz_spline = self._psi_rz_spline.partial_derivative(0, 1)

        # Check the psi grids
        psi = np.asanyarray(psi, dtype=float)
        f = np.asanyarray(f, dtype=float)
        ff_prime = np.asanyarray(ff_prime, dtype=float)
        p = np.asanyarray(p, dtype=float)
        p_prime = np.asanyarray(p_prime, dtype=float)
        q = np.asanyarray(q, dtype=float)
        r_major = np.asanyarray(r_major, dtype=float)
        r_minor = np.asanyarray(r_minor, dtype=float)
        # Ensure psi is 1D and monotonically increasing
        if len(psi.shape) != 1:
            raise ValueError("The grid psi must be 1D.")
        if np.any(np.diff(psi) <= 0):
            raise ValueError("The grid psi must have a positive spacing.")
        # Ensure all psi grids have the correct shape
        psi_grids = {
            "f": f,
            "ff_prime": ff_prime,
            "p": p,
            "p_prime": p_prime,
            "q": q,
            "r_major": r_major,
            "r_minor": r_minor,
            "z_mid": z_mid,
        }
        psi_shape = psi.shape
        for name, grid in psi_grids.items():
            if not np.array_equal(grid.shape, psi_shape):
                raise ValueError(
                    f"The grid {name} has shape {grid.shape}. "
                    f"It should have shape {psi_shape}."
                )

        # Check that floats are valid
        psi_lcfs: float(psi_lcfs)
        if psi_lcfs < psi[0]:
            raise ValueError("psi_lcfs should be greater than psi[0].")
        a_minor: float(a_minor)
        if a_minor <= 0.0:
            raise ValueError("a_minor should be a positive float.")

        # Check r_minor and create normalised version 'rho'
        if r_minor[0] != 0.0:
            raise ValueError("r_minor[0] should be zero.")
        if np.any(np.diff(r_minor) <= 0):
            raise ValueError("The grid r_minor must have a positive spacing.")
        rho = r_minor / a_minor

        # Create normalised 1d psi grid
        psi_n = (psi - psi[0]) / (psi_lcfs - psi[0])

        # Create spline functions for all psi grids with respect to psi
        self._f_psi_spline = spline(psi, f)
        self._ff_prime_psi_spline = spline(psi, ff_prime)
        self._p_psi_spline = spline(psi, p)
        self._p_prime_psi_spline = spline(psi, p_prime)
        self._q_psi_spline = spline(psi, q)
        self._r_major_psi_spline = spline(psi, r_major)
        self._r_minor_psi_spline = spline(psi, r_minor)
        self._z_mid_psi_spline = spline(psi, z_mid)

        # Create select spline derivatives
        self._dq_dpsi_spline = self._q_psi_spline.derivative()
        self._drminor_dpsi_spline = self._r_minor_psi_spline.derivative()
        self._drmajor_dpsi_spline = self._r_major_psi_spline.derivative()
        self._dzmid_dpsi_spline = self._z_mid_psi_spline.derivative()

        # Assemble grids into underlying xarray Dataset
        # TODO units
        super().__init__(
            coords={
                "r": r,
                "z": z,
                "psi": psi,
            },
            data_vars={
                "psi_rz": (("r", "z"), psi_rz),
                "f": ("psi", f),
                "ff_prime": ("psi", ff_prime),
                "p": ("psi", p),
                "p_prime": ("psi", p_prime),
                "q": ("psi", q),
                "r_major": ("psi", r_major),
                "r_minor": ("psi", r_minor),
                "z_mid": ("psi", z_mid),
                "rho": ("psi", rho),
                "psi_n": ("psi", psi_n),
            },
            attrs={
                "r_axis": r_major[0],
                "z_axis": z_mid[0],
                "psi_axis": psi[0],
                "psi_lcfs": psi_lcfs,
                "a_minor": a_minor,
                "dr": r[1] - r[0],
                "dz": z[1] - z[0],
            },
        )

    # define properties for read-only access to attrs
    r_axis = property(lambda self: self.data.r_axis)
    z_axis = property(lambda self: self.data.z_axis)
    psi_axis = property(lambda self: self.data.psi_axis)
    psi_lcfs = property(lambda self: self.data.psi_lcfs)
    a_minor = property(lambda self: self.data.a_minor)
    dr = property(lambda self: self.data.dr)
    dz = property(lambda self: self.data.dz)

    def psi(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return actual poloidal magnetic flux function :math:`\psi` for a given
        normalised :math:`\psi_n`, defined as :math:`\psi_n=0` on the magnetic axis and
        :math:`\psi_n=1` on the last closed flux surface. Units are Webers per radian.
        """
        return self.psi_axis + np.asanyarray(psi_n) * (self.psi_lcfs - self.psi_axis)

    def psi_n(self, psi: ArrayLike) -> np.ndarray:
        r"""
        Return normalised poloidal magnetic flux function :math:`\psi_n` for a given
        actual :math:`\psi`.
        """
        return (np.asanyarray(psi) - self.psi_axis) / (self.psi_lcfs - self.psi_axis)

    def f(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return poloidal current function :math:`f` at the normalised poloidal magnetic
        flux function :math:`\psi_n`.
        """
        return self._f_psi_spline(self.psi(psi_n))

    def ff_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return poloidal current function :math:`f` multiplied by its derivative with
        respect to :math:`\psi` for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.
        """
        return self._ff_prime_psi_spline(self.psi(psi_n))

    def f_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative of the poloidal current function :math:`f` with respect to
        :math:`\psi` for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.
        """
        return self.ff_prime(psi_n) / self.f_prime(psi_n)

    def p(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return plasma pressure for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.
        """
        return self._p_psi_spline(self.psi(psi_n))

    def p_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative of the plasma pressure with respect to :math:`\psi` for a
        given normalised poloidal magnetic flux function :math:`\psi_n`.
        """
        return self._p_prime_psi_spline(self.psi(psi_n))

    def q(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the safety factor for a given normalised poloidal magnetic flux function
        :math:`\psi_n`.
        """
        return self._q_psi_spline(self.psi(psi_n))

    def q_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the derivative of the safety factor with respect to :math:`\psi` for a
        given normalised poloidal magnetic flux function :math:`\psi_n`.
        """
        return self._dq_dpsi_spline(self.psi(psi_n))

    def r_major(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the major radius position of the midpoint of the flux surface represented
        by a given normalised poloidal magnetic flux function :math:`\psi_n`.
        """
        return self._r_major_psi_spline(self.psi(psi_n))

    def r_major_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative with respect to :math:`\psi` of the major radius position of
        the midpoint of the flux surface represented by a given normalised poloidal
        magnetic flux function :math:`\psi_n`.
        """
        return self._drmajor_dpsi_spline(self.psi(psi_n))

    def r_minor(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return half of the width of the flux surface represented by a given normalised
        poloidal magnetic flux function :math:`\psi_n`.
        """
        return self._r_minor_psi_spline(self.psi(psi_n))

    def r_minor_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return derivative with respect to :math:`\psi` of the width of the flux surface
        represented by a given normalised poloidal magnetic flux function
        :math:`\psi_n`.
        """
        return self._drminor_dpsi_spline(self.psi(psi_n))

    def z_mid(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the vertical position of the midpoint of the flux surface represented by
        a given normalised poloidal magnetic flux function :math:`\psi_n`.
        """
        return self._z_mid_psi_spline(self.psi(psi_n))

    def z_mid_prime(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the derivative with respect to :math:`\psi` of the vertical position of
        the midpoint of the flux surface represented by a given normalised poloidal
        magnetic flux function :math:`\psi_n`.
        """
        return self._dzmid_dpsi_spline(self.psi(psi_n))

    def rho(self, psi_n: ArrayLike) -> np.ndarray:
        r"""
        Return the normalised minor radius of the flux surface represented by a given
        normalised poloidal magnetic flux function :math:`\psi_n`. This is the same as
        ``r_minor/a_minor``.
        """
        return self.r_minor(psi_n) / self.a_minor

    def br(self, r: ArrayLike, z: ArrayLike) -> np.ndarray:
        r"""
        Return the radial magnetic flux density at the position(s) ``(r, z)``.
        """
        r = np.asanyarray(r)
        z = np.asanyarray(z)
        return -self._dpsi_dz_spline(r, z, grid=False) / r

    def bz(self, r: ArrayLike, z: ArrayLike) -> np.ndarray:
        r"""
        Return the vertical magnetic flux density at the position(s) ``(r, z)``.
        """
        r = np.asanyarray(r)
        z = np.asanyarray(z)
        return self._dpsi_dr_spline(r, z, grid=False) / r

    def bp(self, r: ArrayLike, z: ArrayLike) -> np.ndarray:
        r"""
        Return the magnitude of the polooidal magnetic flux density at the position(s)
        ``(r, z)``.
        """
        return np.hypot(self.br(r, z), self.bz(r, z))

    def bt(self, r: ArrayLike, z: ArrayLike) -> np.ndarray:
        r"""
        Return the toroidal magnetic flux density at the position(s) ``(r, z)``.
        """
        r = np.asanyarray(r)
        z = np.asanyarray(z)
        # Get psi along the path, use this to get f
        psi = self._psi_rz_spline(r, z, grid=False)
        return self.f(self.psi_n(psi)) / r

    def flux_surface(self, psi_n) -> FluxSurface:
        r"""
        Generate a FluxSurface object representing the flux surface with normalised
        poloidal magnetic flux function :math:`\psi_n`. This Dataset-like object
        contains information such as the path swept out by the flux surface in
        ``(r_major, z)`` coordinates, the magnetic flux density along the path, and
        quantities such as pressure, safety factor, the poloidal current function
        :math:`f`, and their derivatives with respect to :math:`\psi` on the flux
        surface. It also contains derivatives with respect to the minor radius of
        the flux surface, and normalised versions of :math:`\psi`
        """
        # Get rz contours
        r, z = _flux_surface_contour(
            self["r"],
            self["z"],
            self["psi_rz"],
            self.r_axis,
            self.z_axis,
            self.psi(psi_n),
        )

        # Get magnetic field quantities around the contour path
        br = self.br(r, z)
        bz = self.bz(r, z)
        bt = self.bt(r, z)

        return FluxSurface(
            r=r,
            z=z,
            br=br,
            bz=bz,
            bt=bt,
            f=self.f(psi_n),
            f_prime=self.f_prime(psi_n),
            p=self.p(psi_n),
            p_prime=self.p_prime(psi_n),
            q=self.q(psi_n),
            q_prime=self.q_prime(psi_n),
            r_major=self.r_major(psi_n),
            r_major_prime=self.r_major_prime(psi_n),
            r_minor=self.r_minor(psi_n),
            r_minor_prime=self.r_minor_prime(psi_n),
            z_mid=self.z_mid(psi_n),
            z_mid_prime=self.z_mid_prime(psi_n),
            psi_axis=self.psi_axis,
            psi_lcfs=self.psi_lcfs,
            a_minor=self.a_minor,
        )

    def __deepcopy__(self, memodict):
        """Copy Equilibrium object in full, following references down the stack."""
        # Create new object without calling __init__
        new_equilibrium = Equilibrium.__new__(Equilibrium)
        # Deep copy each member individually
        for key, value in vars(self).items():
            setattr(new_equilibrium, key, deepcopy(value, memodict))
        return new_equilibrium


# Create global instance of reader factory
_equilibrium_readers = create_reader_factory()


def equilibrium_reader(key: str) -> None:
    r"""
    Decorator for classes that inherit Reader and create Equilibrium objects. Registers
    classes with the global factory, and sets the class-level attribute 'file_type'
    to the provided key. Can be used to register user-created plugins for equilibrium
    file readers.

    Examples
    --------

    ::

        # Use this to decorate classes which inherit Reader and define the functions
        # 'read' and (optionally) 'verify'. Provide a key that will be used as an
        # identifier.
        @equilibrium_reader("MyEquilibrium")
        class MyEquilibriumReader(Reader):

            def read(self, path):
                pass

            def verify(self, path):
                pass

        # MyEquilibriumReader will now contain the 'file_type' attribute
        assert MyEquilibriumReader.file_type == "MyEquilibrium"

        # The user can now read files of this type
        eq = read_equilibrium("MyEquilibrium.txt", eq_type="MyEquilibrium")
    """

    def decorator(cls: Type[Reader]):
        _equilibrium_readers[key] = cls
        cls.file_type = key
        return cls

    return decorator


def read_equilibrium(
    path: PathLike,
    *args,
    eq_type: Optional[str] = None,
    **kwargs,
) -> Equilibrium:
    r"""
    Read a plasma equilibrium file from disk, returning an ``Equilibrium`` instance.

    Parameters
    ----------
    path: PathLike
        Location of the equilibrium file on disk.
    *args:
        Positional arguments forwarded to the equilibrium file reader.
    eq_type: Optional[str]
        String specifying the type of equilibrium file. If unset, the file type will be
        inferred automatically. Specifying the file type may improve performance.
    **kwargs:
        Keyword arguments forwarded to the equilibrium file reader.

    Returns
    -------
    Equilibrium

    Raises
    ------
    ValueError
        If ``path`` does not refer to a valid file.
    RuntimeError
        If ``eq_type`` is unset, and it is not possible to infer the file type
        automatically.
    """
    path = Path(path)
    if not path.is_file():
        raise ValueError(f"File {path} not found.")
    # Infer reader type from path if not provided with eq_type
    reader = _equilibrium_readers[path if eq_type is None else eq_type]
    return reader(path, *args, **kwargs)


def supported_equilibrium_files() -> List[str]:
    """Returns a list of supported equilibrium file types."""
    return [*_equilibrium_readers]
