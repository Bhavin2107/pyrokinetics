from collections import Counter
from pathlib import Path
from typing import Union

from typing_extensions import Self

from .local_geometry import LocalGeometry
from .local_species import LocalSpecies
from .normalisation import ConstNormalisation
from .numerics import Numerics
from .typing import PathLike


__all__ = ["LocalGKSimulation"]


class LocalGKSimulation:

    _base_name: str
    _name: str
    _norms: ConstNormalisation
    _geometry: LocalGeometry
    # _species: LocalSpecies # TODO
    _numerics: Numerics

    _RUN_NAMES = Counter()

    def __init__(
        self,
        base_name: str,
        name: str,
        norms: ConstNormalisation,
        geometry: LocalGeometry,
        # species: LocalSpecies, # TODO
        numerics: Numerics,
    ) -> None:
        """Describes a gyrokinetics simulation in a self-consistent manner.

        Gyrokinetics simulations are typically defined in terms of normalised
        units. This means that modifying one aspect of a simulation can
        necessitate modifications elsewhere to maintain consistency. For
        example, modifying the minor radius of the flux surface may change the
        reference length against which many other quanitities are defined, such
        as spatial derivatives.

        This class is used to ensure that modifications to one aspect of a
        simulation, such as the geometry or species under study, are reflected
        in the others. It achieves this by generating a new system of reference
        units at each modification, and converting all components to match.
        Instances should be considered immutable, and each modification should
        generate a new instance.

        It is recommended to build new instances using the class method
        :method:`LocalGKSimulation.new` instead of the basic ``__init__``
        function.

        TODO the preferred interface in future should be ``read_gk_input``.

        Parameters
        ----------
        base_name
            A reference name for the simulation.
        name
            The ``base_name`` with a unique number code. This should be
            generated by :method:`LocalGKSimulation._unique_name`.
        geometry
            Describes the parameterisation of the simulation's flux surface.
            Should be set up to match with ``norms`` in advance.
        species
            Includes information such as mass, charge, and temperature for each
            species. Should be set up to match with ``norms`` in advance.
        numerics
            Describes non-physical aspects of the simulation, such as grid
            dimensions. Should be set up to match with ``norms`` in advance.
        norms
            The system of normalised units shared by all components of the
            simulation.
        """
        if not self._check_name(name, base_name):
            raise ValueError(f"Name {name} does not match base name {base_name}")
        self._base_name = base_name
        self._name = name
        self._norms = norms
        self._geometry = geometry
        # self._species = species # TODO
        self._numerics = numerics

    @classmethod
    def new(
        cls,
        geometry: LocalGeometry,
        # species: LocalSpecies, # TODO
        numerics: Numerics,
        convention: str,
        name: str = "pyro",
    ) -> Self:
        """Build a new
        Parameters
        ----------
        geometry
            Describes the parameterisation of the simulation's flux surface.
        species
            Includes information such as mass, charge, and temperature for each
            species.
        numerics
            Describes non-physical aspects of the simulation, such as grid
            dimensions.
        convention
            The system of normalised units shared by all components of the
            simulation.
        name
            A reference name for this simulation. Any physical units will
            include this reference along with a unique number code.
        """
        base_name = name
        name = cls._unique_name(name)

        # Create set of normalised units
        norms = ConstNormalisation(
            name=name,
            convention=convention,
            B0=geometry.B0,
            bunit_over_b0=geometry.bunit_over_b0,
            minor_radius=geometry.a_minor,
            aspect_ratio=geometry.Rmaj / geometry.a_minor,
            electron_temperature=1.0,
            deuterium_temperature=1.0,
            electron_density=1.0,
            deuterium_density=1.0,
            electron_mass=1.0,
            hydrogen_mass=1.0,
            deuterium_mass=1.0,
            tritium_mass=1.0,
        )

        # Apply units to each component
        geometry = geometry.with_units(norms)
        # species = species.with_units(norms) # TODO
        numerics = numerics.with_units(norms)
        return cls(base_name, name, norms, geometry, numerics)

    def to_convention(self, convention: str) -> Self:
        """Creates a copy with a new units convention."""
        base_name = self._base_name
        name = self._unique_name(self._base_name)
        norms = self._norms.with_convention(convention.lower(), name=name)
        geometry = self._geometry.with_units(norms)
        # species = self._species.with_units(norms) # TODO
        numerics = self._numerics.with_units(norms)
        return self.__class__(base_name, name, norms, geometry, numerics)

    def to_gk_code(self, gk_code: str) -> Self:
        """Alias to :method:`LocalGKSimulation:to_convention`."""
        return self.to_convention(convention=gk_code)

    def with_geometry(self, geometry: LocalGeometry) -> Self:
        """Creates a new simulation with modified geometry parameters."""
        base_name = self._base_name
        name = self._unique_name(self._base_name)
        norms = self._norms.with_geometry_params(
            name=name,
            B0=geometry.B0,
            bunit_over_b0=geometry.bunit_over_b0,
            minor_radius=geometry.a_minor,
            aspect_ratio=geometry.Rmaj / geometry.a_minor,
        )
        new_geometry = geometry.with_units(norms)
        # species = species.with_units(norms) # TODO
        numerics = self._numerics.with_units(norms)
        return self.__class__(base_name, name, norms, new_geometry, numerics)

    def with_species(self, species: LocalSpecies) -> Self:
        """Creates a new simulation with modified species parameters."""
        # TODO
        return self

    @classmethod
    def _unique_name(cls, name: Union[str, PathLike]) -> str:
        """Return a unqiuely numbered run name from `name`"""
        # name might be a Path, in which case just use the filename
        # (without extension)
        name = Path(name).stem
        name = "".join([ch for ch in name if ch.isalpha() or ch.isdigit() or ch == "_"])
        new_name = f"{name}{cls._RUN_NAMES[name]:06}"
        cls._RUN_NAMES[name] += 1
        return new_name

    @staticmethod
    def _check_name(name: str, base_name: str) -> bool:
        """Ensure a simulation name is of the correct format.

        ``name`` should be a string generated by the class method
        :method:`LocalGKSimulation._unique_name`.
        """
        # Seems to handle strings smaller than 6 characters just fine
        return name[:-6] == base_name and name[-6:].isdigit()
